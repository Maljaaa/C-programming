#define _CRT_SECURE_NO_WARNINGS	// strcpy쓰기 위해
#include <iostream>
#include <cstring>
#include <string>
#include <fstream>
#include <vector>
using namespace std;

// 1강 C++ 소개 --------------------------------------------------------------------------------------------------------------------
/*
// 현재 가진 돈으로 살 수 있는 캔디의 갯수와 남은 돈 계산
int main() {
	int money;
	int candy_price;

	cout << "현재 가지고 있는 돈 ";
	cin >> money;
	cout << "캔디의 가격 ";
	cin >> candy_price;

	int n_candies = money / candy_price;
	cout << "최대로 살 수 있는 캔디의 개수 = " << n_candies << endl;

	int charge = money % candy_price;
	cout << "캔디 구입 후 남은 돈 = " << charge << endl;
	
	return 0;
}
*/

/*
// 화씨 온도를 섭씨 온도로
int main() {
	double f_temp;
	double c_temp;

	cout << "화씨 온도 : ";
	cin >> f_temp;

	// 화씨온도로 섭씨온도를 구하는 공식
	c_temp = (5.0 / 9.0) * (f_temp - 32);

	cout << "화씨 온도" << f_temp << "도는 섭씨 온도" << c_temp << "도 입니다." << endl;
	return 0;
}
*/

/*
// 2개의 주사위를 던져서 주사위의 합을 표시
#include <ctime>
#include <cstdlib>
int main() {

	srand(time(NULL)); // seed값 생성
	int dice1 = (rand() % 6) + 1;
	int dice2 = (rand() % 6) + 1;

	cout << "두 주사위 합 = " << dice1 + dice2 << endl;
	return 0;
}
*/

// 2강 제어구조와 배열 ------------------------------------------------------------------------------------------------------------
/*
* 참 거짓 판단
int main() {
	bool b;
	b = (1 == 2);

	cout << boolalpha;
	cout << b << endl;

	return 0;
}
*/

/*
// 크기 비교
int main() {
	int x, y;

	cout << "x값을 입력하세요 : ";
	cin >> x;

	cout << "y값을 입력하세요 : ";
	cin >> y;

	if (x > y) {
		cout << "x가 y보다 크다." << endl;
	}
	else {
		cout << "y가 x보다 크다." << endl;
	}

	return 0;
}
*/

/*
// 변수가 어린이, 청소년, 성인인지 판별
int main() {
	int age;
	cout << "나이를 입력하세요 : ";
	cin >> age;

	if (age <= 12) {
		cout << "어린이" << endl;
	}
	else if (age <= 19) {
		cout << "청소년" << endl;
	}
	else {
		cout << "어른" << endl;
	}

	return 0;
}
*/

/*
// 컴퓨터가 숨기고 있는 비밀 코드를 추측하는 게임, a~z사이의 문자
int main() {
	char secret_code = 'h';

	cout << "비밀코드를 맞춰보세요 : ";
	char code;
	cin >> code;
	if (code < secret_code)
		cout << code << "뒤에 있음" << endl;
	else if (code > secret_code)
		cout << code << "앞에 있음" << endl;
	else
		cout << "딩동댕" << endl;

	return 0;
}
*/

/*
// 3개의 정수를 받아서 가장 큰 수 찾기
int main() {
	int x, y, z, largest;

	cout << "3개의 정수를 입력하세요 : ";
	cin >> x >> y >> z;

	if (x > y && x > z)
		largest = x;
	else if (y > x && y > z)
		largest = y;
	else
		largest = z;

	cout << "가장 큰 수는 " << largest << endl;

	return 0;
}
*/

/*
// 카운트다운
int main() {
	int n = 10;
	while (n > 0) {
		cout << n << " ";
		n--;
	}
	cout << "발사!" << endl;

	return 0;
}
*/

/*
// 구구단 출력
int main() {
	int n;
	int i = 1;

	cout << "구구단 중에서 출력하고 시은 단을 입력하세요 : ";
	cin >> n;

	while (i <= 9) {
		cout << n << " * " << i << " = " << n * i << endl;
		i++;
	}
	return 0;
}
*/

/*
// "종료" 입력하기 전까지 입력을 그대로 출력
#include <string>
int main() {
	
	string str;
	
	do {
		cout << "문자열을 입력하세요 : ";
		getline(cin, str); // 한 줄의 텍스트를 받을 때
		cout << "사용자의 입력 : " << str << endl;
	} while (str != "종료");
	
	return 0;
}
*/

/*
// 1~10 정수를 더해 합을 구하기
int main() {
	int sum = 0;
	for (int i = 1; i <= 10; i++) {
		sum += i;
	}

	cout << "합 = " << sum << endl;
	return 0;
}
*/

/*
// 팩토리얼 값 계산
int main() {
	long fact = 1;
	int n;

	cout << "정수를 입력하세요 : ";
	cin >> n;

	for (int i = 1; i <= n; i++) {
		fact = fact * i;
	}
	cout << n << "!은" << fact << "입니다." << endl;

	return 0;
}
*/

/*
// 영문자를 받아서 자음과 모음의 개수를 세는 프로그램
int main() {
	int vowel = 0, consonant = 0;
	char ch;

	cout << "영문자를 입력하고 컨트롤 -z를 치세요" << endl;
	while (cin >> ch) {
		switch (ch) {
		case 'a' : case'i' :case 'e' : case 'o': case 'u':
			vowel++;
			break;
		default :
			consonant++;
			break;
		}
	}
	cout << "모음 : " << vowel << endl;
	cout << "자음 : " << consonant << endl;
}
*/

/*
// 1~100사이 업다운 게임
#include <ctime>
int main() {
	srand(time(NULL));

	int answer = rand() % 100 + 1;
	int guess;
	int tries = 0;

	do {
		cout << "정답을 추측하여 보시오 : ";
		cin >> guess;
		tries++;

		if (guess > answer) {
			cout << "제시한 정수가 높습니다.\n";
		}
		if (guess < answer) {
			cout << "제시한 정수가 낮습니다.\n";
		}
	} while (guess != answer);

	cout << "딩동댕!(시도횟수 : " << tries << ")" << endl;

	return 0;
}
*/

/*
// 산수 문제 자동 출제
#include <cstdlib>
int main() {
	int i, ans;

	cout << "산수 문제를 자동으로 출제합니다." << endl;

	while (true) {
		int x = rand() % 100;
		int y = rand() % 100;
		cout << x << " + " << y << " = ";
		cin >> ans;
		if (x + y == ans) {
			cout << "Correct!" << endl;
			break;
		}
		else
			cout << "Wrong,,,," << endl;
	}
	return 0;
}
*/

/*
// 성적 입력 받아서 평균을 구하는 프로그램(배열 이용)
int main() {
	const int STUDENTS = 10; // 기호 상수 선언(변경 불가능)
	int scores[STUDENTS];
	int sum = 0;
	int i, average;

	for (i = 0; i < STUDENTS; i++) {
		cout << "학생들의 성적을 입력하세요 : ";
		cin >> scores[i];
	}
	for (i = 0; i < STUDENTS; i++)
		sum += scores[i];

	average = sum / STUDENTS;
	cout << "평균은 " << average << endl;

	return 0;
}
*/

/*
// 크기가 100인 배열을 1~100 사이의 난수로 채우고 최대값 찾기
#include <cstdlib>

int main() {
	int list[10];
	int max;

	for (int& elem : list) {
		elem = rand() % 100 + 1;
		cout << elem << " ";
	}
	cout << endl;

	max = list[0];
	for (auto& elem : list) {
		if (elem > max)
			max = elem;
	}
	cout << "최댓값 : " << max << endl;

	return 0;
}
*/

/*
// 구구단의 저장
#define WIDTH 9
#define HEIGHT 9
int main() {
	int table[HEIGHT][WIDTH];
	int r, c;

	for (r = 0; r < HEIGHT; r++)
		for (c = 0; c < WIDTH; c++)
			table[r][c] = (r + 1) * (c + 1);

	for (r = 0; r < HEIGHT; r++) {
		for (c = 0; c < WIDTH; c++) {
			cout << table[r][c] << ", ";
		}
		cout << endl;
	}
}
*/

/*
// Tic-Tac-Toc 게임 (2명의 경기자가 보드에 o,x 번갈아 놓기)
int main() {
	char board[3][3];
	int x, y, k, i;

	// 보드 초기화
	for (x = 0; x < 3; x++)
		for (y = 0; y < 3; y++)
			board[x][y] = ' ';

	for (k = 0; k < 9; k++) {
		cout << "(x, y)좌표 : ";
		cin >> x >> y;
		board[x][y] = (k % 2 == 0) ? '  X' : '  O'; // 번갈아 가면서 넣기
		// 보드 그리기
		for (i = 0; i < 3; i++) {
			cout << "---|---|---" << endl;
			cout << board[i][0] << "  |" << board[i][1] << "  |" << board[i][2] << endl;
		}
		cout << "---|---|---" << endl;
	}
	return 0;
}
*/

/*
// 제곱 만들기
int square(int n) {
	return n * n;
}

int main() {
	int n;
	cout << "제곱할 정수를 입력하시오 : ";
	cin >> n;

	cout << square(n) << endl;
	return 0;
}
*/

/*
// swap (별칭을 활용, call by reference)
void swap(int& x, int& y) {
	int temp;

	temp = x;
	x = y;
	y = temp;
}

int main() {
	int a = 100, b = 200;
	cout << "a = " << a << " b = " << b << endl;
	swap(a, b);
	cout << "a = " << a << " b = " << b << endl;
	return 0;
}
*/

/*
// overloading ex
int square(int i) {
	cout << "square(int)호출" << endl;
	return i * i;
}

double square(double i) {
	cout << "square(double)호출" << endl;
	return i * i;
}

int main() {
	cout << square(5) << endl;
	cout << square(5.5) << endl;

	return 0;
}
*/

/*
// 정수, 실수, 문자를 모두 출력할 수 있는 prin()함수를 overloading
void print(int i) {
	cout << "정수 출력 : " << i << endl;
}

void print(double i) {
	cout << "실수 출력 : " << i << endl;
}

void print(char i) {
	cout << "문자 출력 : " << i << endl;
}

int main() {
	print(100);
	print(3.14);
	print('C');

	return 0;
}
*/

/*
// default argument ex
void display(char c = '*', int n = 10) {	// 아무것도 입력되지 않았을 떄 자동으로 입력되는 값 = default값
	for (int i = 0; i < n; i++) {
		cout << c;
	}
	cout << endl;
}

int main() {
	cout << "아무런 인수가 전달되지 않는 경우 : \n";
	display();

	cout << "\n 첫 번째 인수만 전달되는 경우 : \n";
	display('#');

	cout << "\n 모든 인수가 전달되는 경우 : \n";
	display('#', 5);

	return 0;
}
*/

/*
// default argument ex2
int sum(int a = 0, int b = 0, int c = 0, int d = 0) {
	return a + b + c + d;
}

int main() {
	cout << "sum(10, 15) = " << sum(10, 15) << endl;
	cout << "sum(10, 15, 25) = " << sum(10, 15, 25) << endl;
	cout << "sum(10, 15, 25, 30) = " << sum(10, 15, 25, 30) << endl;
	
	return 0;
}
*/

/*
// 이름과 주소 받아서 인사하는 프로그램
#include <string>

int main() {
	string s1, addr;

	cout << "이름을 입력하시오 : ";
	cin >> s1;
	cin.ignore(); // 엔터키 없애기 위해

	cout << "주소를 입력하시오 : ";
	getline(cin, addr);
	cout << addr << "의 " << s1 << "씨 안녕하세요?" << endl;

	return 0;
}
*/

/*
// "When in Rome, do as the Romans." 중에서 "Rome"이 몇 번째 위치에 있는지 계산하는 프로그램
#include <string>

int main() {
	string s = "When in Rome, do as the Romans.";

	int index = s.find("Rome"); // 공백 포함
	cout << index << endl;

	return 0;
}
*/

/*
// 주민등록번호 '-' 삭제하는 프로그램
#include <string>

int main() {
	string s;
	cout << "주민등록번호를 입력하시오 : ";
	cin >> s;

	cout << "-가 제거된 주민등록 번호 : ";
	for (auto& c : s) {
		if (c == '-')continue;
		cout << c;
	}
	cout << endl;

	return 0;
}
*/

/*
// Hamming distance(서로 다른 글자 갯수 계산) 
#include <string>

int main() {
	string s1, s2;
	int count = 0;

	cout << "DNA1 : ";
	cin >> s1;
	cout << "DNA2 : ";
	cin >> s2;

	if (s1.length() != s2.length())
		cout << "오류 : 길이가 다름" << endl;
	else {
		for (int i = 0; i < s1.length(); i++) {
			if (s1[i] != s2[i]) {
				count += 1;
			}
		}
		cout << "해밍 거리는 " << count << endl;
	}
	return 0;
}
*/

/*
// Hang Man Game
#include <string>

int main() {
	char ch;
	string solution;
	string list[] = { "the", "c++", "programming", "language" }; // 낼 수 있는 문제

	int n = rand() % 4;
	solution = list[n];

	string guess(solution.length(), '_');

	while (true) {
		cout << guess << endl;
		cout << "글자를 입력하시오 : ";
		cin >> ch;
		for (int i = 0; i < solution.length(); i++) {
			if (ch == solution[i]) {
				guess[i] = ch;
			}
		}
		

		if (solution == guess) {
			cout << solution << endl;
			cout << "성공하였습니다!";
			break;
		}
	}
	return 0;
}
*/

// 4강 클래스와 객체---------------------------------------------------------------------------------------------------------------

/*
// class ex
class Circle {
public :
	int radius;
	string color;

	double calcArea() {
		return 3.14 * radius * radius;
	}
};

int main() {
	Circle obj;

	obj.radius = 100;
	obj.color = "blue";

	cout << "원의 면적 = " << obj.calcArea() << "\n";
	return 0;
}
*/

/*
// 여러개의 객체 생성 예제
class Circle {
public:
	int radius;
	string color;

	double calcArea() {
		return 3.14 * radius * radius;
	}
};

int main() {
	Circle pizza1, pizza2;

	pizza1.radius = 100;
	pizza1.color = "yellow";
	cout << "피자의 면적 = " << pizza1.calcArea() << endl;

	pizza2.radius = 200;
	pizza2.color = "white";
	cout << "피자의 면적 = " << pizza2.calcArea() << endl;

	return 0;
}
*/

/*
// Rectangle class로 객체를 생성하는 프로그램
class Rectangle {
public :
	int width, height;
	int calcArea() {
		return width * height;
	}
};

int main() {
	Rectangle rect;

	rect.width = 10;
	rect.height = 20;

	cout << rect.calcArea() << endl;

	return 0;
}
*/

/*
// Car class
class Car {
public :
	int speed;
	int gear;
	string color;

	void speedUp() {
		speed += 10;
	}

	void speedDown() {
		speed -= 10;
	}
};

int main() {
	Car myCar;

	myCar.speed = 100;
	myCar.gear = 3;
	myCar.color = "red";

	myCar.speedUp();
	myCar.speedDown();

	return 0;
}
*/

/*
// Overloading ex
class PrintData {
public :
	void print(int i) {
		cout << i << endl;
	}
	void print(double f) {
		cout << f << endl;
	}
	void print(string s = "No Data!") {
		cout << s << endl;
	}
};

int main() {
	PrintData obj;

	obj.print(1);
	obj.print(3.14);
	obj.print("C++14 is cool.");
	obj.print();

	return 0;
}
*/

// 5강 생성자와 접근자 & 객체 배열-------------------------------------------------------------------------------------------------
/*
// 생성자를 가진 Circle class
class Circle {
public :
	// 멤버 변수
	int radius;

	// 멤버 함수
	Circle();
	Circle(int r);
	double getArea();
};

Circle::Circle() {
	radius = 1;
	cout << radius << endl;
}

Circle::Circle(int r) {
	radius = r;
	cout << radius << endl;
}

double Circle::getArea() {
	return 3.14 * radius * radius;
}

int main() {
	Circle donut;
	double area = donut.getArea();
	cout << area << endl;

	Circle pizza(30);
	area = pizza.getArea();
	cout << area << endl;
}
*/

/*
// 생성자에서 다른 생성자 호출(위임 생성자 만들기)
class Circle {
public : 
	int radius;

	Circle();
	Circle(int r);
	double getArea();
};

Circle::Circle():Circle(1){} // 위임 생성자

Circle::Circle(int r) { // 타겟 생성자
	radius = r;
	cout << "반지름 " << radius << "인 원 생성" << endl;
}

double Circle::getArea() {
	return 3.14 * radius * radius;
}

int main() {
	Circle donut;
	double area = donut.getArea();
	cout << area << endl;

	Circle pizza(30);
	area = pizza.getArea();
	cout << area << endl;
}
*/

/*
// Rectangle class 만들기
class Rectangle {
public:
	int width, height;

	Rectangle();
	Rectangle(int w, int h);
	Rectangle(int length);
	bool isSquare();
};

Rectangle::Rectangle() {
	width = height = 1;
}

Rectangle::Rectangle(int w, int h) {
	width = w;
	height = h;
}

Rectangle::Rectangle(int length) {
	width = height = length;
}

bool Rectangle::isSquare(){
	if (width == height) 
		return true;

	else
		return false;
}

int main() {
	Rectangle rect1;
	Rectangle rect2(3, 5);
	Rectangle rect3(3);

	if (rect1.isSquare())
		cout << "rect1은 정사각형이다." << endl;
	if (rect2.isSquare())
		cout << "rect2는 정사각형이다." << endl;
	if (rect3.isSquare())
		cout << "rect3은 정사각형이다." << endl;
}
*/

/*
// 사각형을 나타내는 Rectangle 클래스에 생성자를 추가해보자
class Rectangle {
	int width, height;
public : 
	Rectangle(int w, int h);
	int calcArea();
};

Rectangle::Rectangle(int w, int h) {
	width = w;
	height = h;
}

int Rectangle::calcArea() {
	return width * height;
}
*/

/*
// 클래스 작성 실습
class Time {
private :
	int hour;
	int minute;
	int second;
public :
	Time() {
		hour = 0;
		minute = 0;
		second = 0;
	}

	Time(int h, int m, int s) :hour{ h }, minute{ m }, second{ s }{}

	void set_hour(int h) { 
		if (h >= 24)
			hour = 0;
		else
			hour = h; 
	}
	void set_minute(int m) { minute = m; }
	int get_hour(){
		return hour;
	}
	int get_minute() {
		return minute;
	}
	int get_second() {
		return second;
	}

	void inc_hour();
	void print();
};

void Time::inc_hour() {
	++hour;
	if (hour > 23)
		hour = 0;
}

void Time::print() {
	cout << hour << ":" << minute << ":" << second << endl;
}

int main() {
	Time t;
	Time t2(1, 30, 30);
	t.print();
	t.inc_hour();
	t.print();
	t.set_hour(25);
	t.set_minute(30);
	t.print();
	t2.print();
	cout << "t time : " << t.get_hour() << endl;
	
}
*/
/*
// 접근 제어 예제
class Time {
public :
	Time(int h, int m);
	void inc_hour();
	void print();

	int getHour() { return hour; }
	int getMinute() { return minute; }
	void setHour(int h) { hour = h; }
	void setMinute(int m) { minute = m; }

private :
	int hour;
	int minute;
};

void Time::print() {
	cout << getHour() << ":" << getMinute() << endl;
}

int main() {
	Time a{ 0, 0 };

	a.setHour(19);
	a.setMinute(26);

	a.print();	// 프린트가 안됨 ㅠㅠ

	return 0;
}
*/

/*
// 객체의 참조자가 함수의 매개 변수로 전달되는 경우 - 미디엄 피자 주문하면 라지로 변경해서 줌
// call by reference 방식
class Pizza {
public :
	Pizza(int s) :size{ s } {}
	int size;
};

void makeDouble(Pizza& p) {	// Pizza p 로 하면 안됨 
	p.size *= 2;
}

int main() {
	Pizza pizza(10);
	makeDouble(pizza);
	cout << pizza.size << "인치 피자" << endl;
	return 0;
}
*/

/*
// 함수가 객체를 반환하는 경우
// call by value 방식
class Pizza {
public :
	Pizza(int s) : size{ s } {} // 멤버 변수 초기화
	int size;
};

Pizza createPizza() {
	Pizza p(10);
	return p;
}

int main() {
	Pizza pizza = createPizza();
	cout << pizza.size << "인치 피자" << endl;

	return 0;
}
*/

/*
// Circle 클래스의 배열 선언 및 활용
class Circle {
	int radius;
public : 
	Circle() { radius = 1; }
	Circle(int r) { radius = r; }
	void setRadius(int r) { radius = r; }
	double getArea();
};

double Circle::getArea() {
	return 3.14 * radius * radius;
}

int main() {
	Circle circleArray[3];

	circleArray[0].setRadius(10);
	circleArray[1].setRadius(20);
	circleArray[2].setRadius(30);

	for (int i = 0; i < 3; i++) {
		cout << "Circle " << i << "의 면적은 " << circleArray[i].getArea() << endl;
	} 

}
*/

/*
// 객체 배열 초기화
class Circle {
	int radius;
public : 
	Circle(int r = 1) { radius = r; }
	void setRadius(int r) { radius = r; }
	double getArea();
};

double Circle::getArea() {
	return 3.14 * radius * radius;
}

int main() {
	Circle circleArray[3] = { Circle(10), Circle(20), Circle() };

	for (int i = 0; i < 3; i++) {
		cout << "Circle " << i << "의 면적은 " << circleArray[i].getArea() << endl;
	} 
}
*/

/*
// 2차원 배열 선언 및 활용
class Circle {
	int radius;
public:
	Circle(int r = 1) { radius = r; }
	void setRadius(int r) { radius = r; }
	double getArea();
};

double Circle::getArea() {
	return 3.14 * radius * radius;
}

int main() {
	Circle circles[2][3] = { {Circle(), Circle(2), Circle(3)}, {Circle(4), Circle(5), Circle(6)} }; // 초기화

	for (int i = 0; i < 2; i++) 
		for (int j = 0; j < 3; j++) {
			cout << "Circle [" << i << ", " << j << "]의 면적은 ";
			cout << circles[i][j].getArea() << endl;
		}
}
*/

/*
// 초기화 예제
class Circle {
public :
	int x, y;
	int radius;
	Circle(int x = 0, int y = 0, int r = 0) : x{ x }, y{ y }, radius{ r }{}
	void print() {
		cout << "반지름 " << radius << " @(" << x << ", " << y << ")" << endl;
	}
};

int main() {
	Circle objArray[10];

	// 범위 기반 loop
	for (Circle& c : objArray) {
		c.x = rand() % 500;
		c.y = rand() % 300;
		c.radius = rand() % 100;
	}

	for (Circle c : objArray)
		c.print();

	return 0;
}
*/

/*
// 여러 권의 책을 저장할 수 있는 객체 배열 books를 생성
class Book {
	string title;
	int price;
public :
	Book(string name = "", int price = 0) : title{name}, price{price}{}
	void print() {
		cout << "제목 : " << title << ",         가격 : " << price << endl;
	}
};

int main() {
	Book books[2] = { Book("어서와 C++", 25000), Book("어서와 C", 22000) };

	cout << "소장하고 있는 책 정보 " << endl;
	cout << "===========================" << endl;
	for (Book& b : books)
		b.print();
	cout << "===========================" << endl;

	return 0;
}
*/

/*
// 벡터의 사용 1
#include <vector>
int main() {
	vector<int> fibonacci{ 0, 1, 1, 2, 3, 5, 8, 13, 21 ,34, 55, 89 };

	for (int& number : fibonacci)
		cout << number << " ";

	cout << endl;
	return 0;
}
*/

/*
// 벡터의 사용 2
#include <vector>
int main() {
	vector<int> v1;

	v1.push_back(10);
	v1.push_back(20);
	v1.push_back(30);
	v1.push_back(40);
	v1.push_back(50);

	cout << "v1 = ";
	for (int& e : v1) {
		cout << e << " ";
	}

	cout << endl;
	return 0;
}
*/

/*
// 벡터의 사용 3
#include <vector>
int main() {
	vector<int> v;
	for (int i = 0; i < 10; ++i) {
		v.push_back(i);
	}

	cout << "현재의 v = ";
	for (int& e : v) {
		cout << e << " ";
	}
	cout << endl;

	cout << "삭제 요소 = ";
	while (v.empty() != true) {
		cout << v.back() << " ";
		v.pop_back();
	}
	cout << endl;
}
*/

/*
// 벡터의 연산자
#include <vector>

int main() {
	vector<int> v1{ 1, 2, 3, 4, 5 };
	vector<int> v2(v1);

	if (v1 == v2) {
		cout << "일치함" << endl;
	}

	return 0;
}
*/

/*
// 벡터에 문자열 저장
#include <vector>
#include <string>

int main() {
	vector<string> vec;

	vec.push_back("milk");
	vec.push_back("bread");
	vec.push_back("butter");
	for (string e : vec)
		cout << " " << e;

	cout << endl;

	return 0;
}
*/

/*
// 벡터에 Circle 객체를 저장
#include <vector>

class Circle {
public:
	int x, y;
	int radius;
	Circle(int x = 0, int y = 0, int r = 0) : x{ x }, y{ y }, radius{ r }{}
	void print() {
		cout << "반지름 " << radius << " @(" << x << ", " << y << ")" << endl;
	}
};

int main() {
	vector<Circle> objArray;

	for (int i = 0; i < 10; i++) {
		Circle obj{ rand() % 300, rand() % 300, rand() % 100 };
		objArray.push_back(obj);
	}
	for (Circle c : objArray)
		c.print();

	return 0;
}
*/

/*
// 벡터와 알고리즘
#include <algorithm>
#include <vector>
#include <string>

class Person {
	string name;
	int age;
public :
	Person(string n, int a) {
		name = n;
		age = a;
	}
	string get_name() { return name; }
	int get_age() { return age; }
	void print() {
		cout << name << " " << age << endl;
	}
};

bool compare(Person& p, Person& q) {
	return p.get_age() < q.get_age(); // < 오름차순(점점 올라가), > 내림차순(점점 내려가)
}

int main() {
	vector<Person> list;

	list.push_back(Person("Kim", 30));
	list.push_back(Person("Park", 22));
	list.push_back(Person("Lee", 26));

	sort(list.begin(), list.end(), compare); // STL이고 sort(시작, 끝, 함수);

	for (auto& e : list) {
		e.print();
	}

	return 0;
}
*/

/*
// 성적 평균 계산하기!! 단, 학생이 몇 명인지 알 수 없다 -> 벡터 사용
#include <vector>

int main() {
	vector<int>scores;
	int i, sum = 0;

	while (true) {
		int score;
		cout << "입력하시오 ( 종료는 -1 ) : ";
		cin >> score;
		if (score == 1) break; // 왜 못나오지..?
		scores.push_back(score);
	}
	for (auto& value : scores)
		sum += value;

	double avg = (double)sum / scores.size();
	cout << "평균 = " << avg << endl;

	return 0;
}
*/

/*
// 영화정보 저장
#include <string>
#include <vector>

class Movie {
	string title;
	double rating;
public :
	Movie(string t = "", double r = 0.0) { title = t, rating = r; }
	void print_movie() {
		cout << title << " : " << rating << endl;
	}
};

int main() {
	vector<Movie> movies;

	movies.push_back(Movie("tiinic", 9.9));
	movies.push_back(Movie("asdfdsa", 9.8));
	movies.push_back(Movie("gkjg", 9.7));

	for (auto& e : movies)
		e.print_movie();

	return 0;
}
*/

/*
// array ex 
// Array 클래스는 vector처럼 동적으로 크기를 변경하는 기능은 없다.
// size(), fill() - 동일한 값으로 채움, empty(), at() - 배열의 요소에 접근, front(), back()
#include <array>

int main() {
	array<int, 3> list{ 1, 2, 3 };

	for (int i = 0; i < list.size(); ++i)
		++list[i];

	for (auto& elem : list)
		cout << elem << " ";
	cout << endl;

	return 0;
}
*/

/*
// 학생을 나타내는 클래스 Student를 정의
// 벡터를 이용하여 동적 객체 배영을 만든다. 사용자로부터 데이터(3명)을 입력받아서 배열에 저장한후
// sort()함수를 사용하여 학점이 높은 순으로 모든 학생들을 나열하여라
#include <vector>
#include <string>
#include <algorithm>

class Student {
	string name;
	double marks;
public :
	Student(string n, double m) : name{ n }, marks{ m }{}
	void print() {
		cout << "이름 : " << name << endl;
		cout << "학점 : " << marks << endl;
	}
	void set_name(string n) {
		name = n;
	}
	string get_name() {
		return name;
	}
	void set_marks(double m) {
		marks = m;
	}
	double get_marks() {
		return marks;
	}
};

bool compare(Student& p, Student& q) {
	return p.get_marks() > q.get_marks();
}

int main() {
	vector<Student> list;
	string name;
	double marks;

	for (int i = 0; i < 3; i++) {
		cout << "이름은 ? ";
		cin >> name;
		cout << "학점은 ? ";
		cin >> marks;
		
		list.push_back(Student(name, marks));
	}
	list[0].set_marks(4.5);
	list.push_back(Student("Jung", 3.0));
	sort(list.begin(), list.end(), compare);
	for (auto& e : list) {
		e.print();
	}
	return 0;
}
*/

// 6강 포인터와 동적객체생성-------------------------------------------------------------------------------------------------------
 
/*
// 동적 메모리 할당 예제
#include <time.h>

int main() {
	int* ptr;
	srand(time(NULL));
	ptr = new int[10];	// 동적 메모리 할당

	for (int i = 0; i < 10; i++) {
		ptr[i] = rand();
	}

	for (int i = 0; i < 10; i++) {
		cout << ptr[i] << " ";
	}

	delete[] ptr;	// 동적 메모리 반납		
	cout << endl;

	return 0;
}
*/

/*
// 스마트 포인터( 자동으로 동적 메모리 삭제 )
#include <memory>

int main() {
	unique_ptr<int> p(new int);
	*p = 99;
}
*/

/*
// 스마트포인터로 배열 가리키기
#include <memory>

int main() {
	unique_ptr<int[]>buf(new int[10]);

	for (int i = 0; i < 10; i++)
		buf[i] = i;

	for (int i = 0; i < 10; i++)
		cout << buf[i] << " ";

	cout << endl;

	return 0;
}
*/

/*
// 객체의 동적 생성
class Dog {
	string name;
	int age;
public :
	Dog() {
		cout << "생성자 호출\n";
		age = 1;
		name = "바둑이";
	}

	~Dog() {
		cout << "소멸자 호출\n";
	}
};

int main() {
	Dog* pDog = new Dog;
	delete pDog;

	return 0;
}
*/

/*
// 포인터를 통하여 멤버 접근하기
class Dog {
	string name;
	int age;
public:
	Dog() {
		cout << "생성자 호출\n";
		age = 1;
		name = "바둑이";
	}

	~Dog() {
		cout << "소멸자 호출\n";
	}
	
	void setAge(int a) {
		age = a;
	}

	int getAge() {
		return age;
	}
};

int main() {
	Dog* pDog = new Dog;
	cout << "강아지 나이 : " << pDog->getAge() << endl;

	pDog->setAge(5);
	cout << "강아지의 나이 : " << pDog->getAge() << endl;

	delete pDog;

	return 0;
}
*/

/*
// 멤버 동적 생성
class Dog {
	int* pWeight;
	int* pAge;
public :
	Dog() {
		pAge = new int(1);
		pWeight = new int(10);
	}

	~Dog() {
		delete pAge;
		delete pWeight;
	}

	int getAge() {
		return *pAge;
	}
	void setAge(int age) {
		*pAge = age;
	}
	int getWeight() {
		return *pWeight;
	}
	void setWeight(int weight) {
		*pWeight = weight;
	}
};

int main() {
	Dog* pDog = new Dog;
	cout << "강아지의 나이 : " << pDog->getAge() << endl;

	pDog->setAge(5);
	cout << "강아지의 나이 : " << pDog->getAge() << endl;

	delete pDog;

	return 0;
}
*/

/*
// 객체 포인터 선언 및 활용
class Circle {
	int radius;
public :
	Circle(int r = 1) {
		radius = r;
	}
	double getArea();
};

double Circle::getArea() {
	return 3.14 * radius * radius;
}

int main() {
	Circle donut;
	Circle pizza(30);

	cout << donut.getArea() << endl;

	Circle* p;
	p = &donut;
	cout << p->getArea() << endl;	// 더 자주 쓰임
	cout << (*p).getArea() << endl;

	p = &pizza;
	cout << p->getArea() << endl;
	cout << (*p).getArea() << endl;

	return 0;
}
*/
/*
// new/delete의 사용
int* pInt = new int;
char* pChar = new char;
Circle* pCicle = new Circle;
delete pInt;
delete pChar;
delete pCircle;
*/

/*
// 정수형 공간의 동적 할당 및 반환 예
int main() {
	int* p;

	p = new int;
	if (!p) {
		cout << "메모리를 할당할 수 없습니다.";
		return 0;
	}

	*p = 5;
	int n = *p;
	cout << "*p = " << *p << endl;
	cout << "n = " << n << endl;

	delete p;

	return 0;
}
*/

/*
// 정수형 배열의 동적 할당 및 반환
// 사용자로부터 입력할 정수의 개수를 입력 받아
// 배열을 동적 할당 받고, 하나씩 정수를 입력 받은 후 합을 출력

int main() {
	cout << "입력할 정수의 개수는 ? ";
	int n;
	cin >> n;
	if (n <= 0)
		return 0;
	int* p = new int[n];
	if (!p) {
		cout << "메모리를 할당할 수 없습니다.";
		return 0;
	}

	for (int i = 0; i < n; i++) {
		cout << i + 1 << "번째 정수 : ";
		cin >> p[i];
	}

	int sum = 0;
	for (int i = 0; i < n; i++) {
		sum += p[i];
	}
	cout << "평균 = " << sum / n << endl;

	delete[] p;
}
*/

/*
// Circle 객체의 동적 생성 및 반환
class Circle {
	int radius;
public :
	Circle(int r = 1) {
		radius = r;
		cout << "생성자 실행 radius = " << radius << endl;
	}
	~Circle() {
		cout << "소멸자 실행 radius = " << radius << endl;
	}
	void setRadius(int r) {
		radius = r;
	}
	double getArea() {
		return 3.14 * radius * radius;
	}
};

int main() {
	Circle* p, * q;
	p = new Circle();
	q = new Circle(30);
	cout << p->getArea() << endl << q->getArea() << endl;
	delete p;
	delete q;
}
*/

/*
// Circle 객체의 동적 생성과 반환 응용
class Circle {
	int radius;
public:
	Circle(int r = 1) {
		radius = r;
		cout << "생성자 실행 radius = " << radius << endl;
	}
	~Circle() {
		cout << "소멸자 실행 radius = " << radius << endl;
	}
	void setRadius(int r) {
		radius = r;
	}
	double getArea() {
		return 3.14 * radius * radius;
	}
};

int main() {
	int radius;
	while (true) {
		cout << "정수 반지름 입력(음수이면 종료)>>";
		cin >> radius;
		if (radius < 0)
			break;
		Circle* p = new Circle(radius);	// 동적 객체 생성
		cout << "원의 면적은 " << p->getArea() << endl;
		delete p;
	}
}
*/

/*
// Circle 배열의 동적 생성 및 반화
class Circle {
	int radius;
public:
	Circle(int r = 1) {
		radius = r;
		cout << "생성자 실행 radius = " << radius << endl;
	}
	~Circle() {
		cout << "소멸자 실행 radius = " << radius << endl;
	}
	void setRadius(int r) {
		radius = r;
	}
	double getArea() {
		return 3.14 * radius * radius;
	}
};

int main() {
	Circle* pArray = new Circle[3];

	pArray[0].setRadius(10);
	pArray[1].setRadius(20);
	pArray[2].setRadius(30);

	for (int i = 0; i < 3; i++) {
		cout << pArray[i].getArea() << endl;
	}

	Circle* p = pArray;
	for (int i = 0; i < 3; i++) {
		cout << p->getArea() << endl;
		p++;
	}

	delete[] pArray;
}
*/

/*
// 객체 배열의 동적 생성과 반환 응용
// 원의 개수를 입력 받고 Circle 배열을 동적 생성
// 반지름 값을 입력 받아 Circle 배열에 저장하고
// 면적이 100 ~ 200 사이인 원의 개수를 출력하라.
class Circle {
	int radius;
public:
	Circle(int r = 1) {
		radius = r;
		cout << "생성자 실행 radius = " << radius << endl;
	}
	~Circle() {
		cout << "소멸자 실행 radius = " << radius << endl;
	}
	void setRadius(int r) {
		radius = r;
	}
	double getArea() {
		return 3.14 * radius * radius;
	}
};

int main() {
	cout << "생성하고자 하는 원의 개수 : ";
	int n, radius;
	cin >> n;

	Circle* pArray = new Circle[n];
	for (int i = 0; i < n; i++) {
		cout << "원" << i + 1 << " : ";
		cin >> radius;
		pArray[i].setRadius(radius);
	}

	int count = 0;
	Circle* p = pArray;
	for (int i = 0; i < n; i++) {
		cout << p->getArea() << " ";
		if (p->getArea() >= 100 && p->getArea() <= 200)
			count++;
		p++;
	}
	cout << endl << "면적이 100에서 200 사이인 원의 갯수는 " << count << endl;

	delete[] pArray;
}
*/

/*
// string 클래스를 이용한 문자열 생성 및 출력
#include <string>

int main() {
	string str;
	string address("전주시 덕진구 안덕원로 251");
	string copyAddress(address);

	char text[] = { 'L', 'o', 'v', 'e', ',', 'C', '+', '+', '\0'};
	string title(text);

	cout << str << endl;
	cout << address << endl;
	cout << copyAddress << endl;
	cout << title << endl;
	//cout << text << endl;
}
*/

/*
// string 배열 선언과 문자열 키 입력 응용
// 5개의 string 배열을 선언하고 getline()을 이용하여 문자열을 입력 받아 사전 순으로 가장 뒤에 나오는 문자열을 출력
#include <string>

int main() {
	string names[5];

	for (int i = 0; i < 5; i++) {
		cout << "이름 >> ";
		getline(cin, names[i], '\n');
	}

	string latter = names[0];
	for (int i = 1; i < 5; i++) {
		if (latter < names[i]) {	// 사전 순으로 latter 문자열이 앞에 온다면
			latter = names[i];
		}
	}
	cout << "사전에서 가장 뒤에 나오는 문자열은 " << latter << endl;
}
*/

/*
// 문자열 입력 받고 회전시키기
#include <string>

int main() {
	string s;

	cout << "문자열을 입력하세요(한글 안됨) " << endl;
	getline(cin, s, '\n');
	int len = s.length();

	for (int i = 0; i < len; i++) {
		string first = s.substr(0, 1); // 맨 앞의 문자 1개를 문자열로 분리
		string sub = s.substr(1, len - 1); // 나머지 문자들을 문자열로 분리
		s = sub + first;
		cout << s << endl;
	}
}
*/

/*
// 덧셈 문자열을 입력 받아 덧셈 실행
int main() {
	string s;
	cout << "7+23+5+100+25와 같이 덧셈 문자열을 입력하세요." << endl;
	getline(cin, s, '\n');
	int sum = 0;
	int startindex = 0;
	while (true) {
		int findex = s.find('+', startindex);
		if (findex == -1) {	// 문자열을 찾을 수 없음
			string part = s.substr(startindex);
			if (part == "") break;	// +로 끝나는 경우
			cout << part << endl;
			sum += stoi(part);
			break;
		}
		int count = findex - startindex;
		string part = s.substr(startindex, count);
		cout << part << endl;
		sum += stoi(part);
		startindex = findex + 1;
	}
	cout << "숫자들의 합은 " << sum;
}
*/


/*
// &가 입력될 때까지 여러 줄의 영문 문자열을 입력받고, 찾는 문자열과 대치할 문자열을 각각 입력 받아 문자열을 변경
#include <string>

int main() {
	string s;
	cout << "여러 줄의 문자열을 입력하세요. 입력의 끝은 &문자입니다." << endl;
	getline(cin, s, '&');
	cin.ignore();
	string f, r;
	cout << endl << "find : ";
	getline(cin, f, '\n');
	cout << "replace : ";
	getline(cin, r, '\n');

	int startIndex = 0;
	while (true) {
		int findex = s.find(f, startIndex);
		if (findex == -1) break;
		s.replace(findex, f.length(), r);
		startIndex = findex + r.length();
	}
	cout << s << endl;
}
*/

/*
// 포인터와 동적 객체생성 실습
class Circle {
	int radius;
public :
	Circle() { radius = 1; }
	~Circle() {
		cout << radius << "bye" << endl;
	}
	int getArea() {
		return 3.14 * radius * radius;
	}
	void setRadius(int radius) {
		this->radius = radius;
	}
	int getRadius() {
		return radius;
	}
};

int main() {
	int n;
	int count = 0;
	cout << "생성할 원의 갯수 : ";
	cin >> n;
	Circle* pC = new Circle[n];
	srand(time(NULL));
	for (int i = 0; i < n; i++) {
		cout << pC[i].getRadius() << "인 원" << endl;
	}
	for (int i = 0; i < n; i++) {
		pC[i].setRadius(rand() % 100 + 1);
	}
	for (int i = 0; i < n; i++) {
		cout << pC[i].getRadius() << "인 원" << endl;
		if (pC[i].getArea() > 100)
			count++;
	}
	cout << "면적이 100 이상인 원의 갯수 : " << count << endl;
	delete[] pC;
}
*/

// 7강 복사생성자와 정적멤버--------------------------------------------------------------------------------------------------

/*
// 객체 리턴 ex
class Circle {
	int radius;
public :
	Circle(int radius = 1) {
		this->radius = radius;
	}
	void setRadius(int radius) {
		this->radius = radius;
	}
	double getArea() {
		return 3.14 * radius * radius;
	}
};

Circle getCircle() {
	Circle tmp(30);
	return tmp; // 객체 tmp를 리턴한다 
}

int main() {
	Circle c;
	cout << c.getArea() << endl;

	c = getCircle();
	cout << c.getArea() << endl;
}
*/

/*
// 객체를 함수로 전달하기( call by value )
class Pizza {
	int radius;
public :
	Pizza(int r = 0):radius{r}{}
	~Pizza(){}
	void setRadius(int r) {
		radius = r;
	}
	void print() {
		cout << "Pizza(" << radius << ")" << endl;
	}
};

void upgrade(Pizza p) {
	p.setRadius(20);
}

int main() {
	Pizza obj(10);
	upgrade(obj);
	obj.print();
	return 0;
}
*/

/*
// 객체의 주소를 함수로 전달하기
class Pizza {
	int radius;
public:
	Pizza(int r = 0) :radius{ r } {}
	~Pizza() {}
	void setRadius(int r) {
		radius = r;
	}
	void print() {
		cout << "Pizza(" << radius << ")" << endl;
	}
};

void upgrade(Pizza* p) {
	p -> setRadius(20);
}

int main() {
	Pizza obj(10);
	upgrade(&obj);

	obj.print();
	return 0;
}
*/

/*
// 객체에 대한 참조
class Circle {
	int radius;
public:
	Circle(int radius = 1) {
		this->radius = radius;
	}
	void setRadius(int radius) {
		this->radius = radius;
	}
	double getArea() {
		return 3.14 * radius * radius;
	}
};

int main() {
	Circle circle;
	Circle& refc = circle;
	refc.setRadius(10);
	cout << refc.getArea() << " " << circle.getArea();
}
*/

/*
// 참조자 매개변수 사용하기
class Pizza {
	int radius;
public:
	Pizza(int r = 0) :radius{ r } {}
	~Pizza() {}
	void setRadius(int r) {
		radius = r;
	}
	void print() {
		cout << "Pizza(" << radius << ")" << endl;
	}
};

void upgrade(Pizza& p) {
	p.setRadius(20);
}

int main() {
	Pizza obj(10);
	upgrade(obj);

	obj.print();
	return 0;
}
*/

/*
// 참조 매개 변수로 평균 리턴하기
bool average(int a[], int size, int& avg) {
	if (size <= 0)
		return false;
	int sum = 0;
	for (int i = 0; i < size; i++) {
		sum += a[i];
	}
	avg = sum / size;
	return true;
}

int main() {
	int x[] = { 0, 1, 2, 3, 4, 5 };
	int avg;
	if (average(x, 6, avg))
		cout << "평균은 " << avg << endl;
	else
		cout << "매개 변수 오류!!" << endl;

	if (average(x, -2, avg))
		cout << "평균은 " << avg << endl;
	else
		cout << "매개 변수 오류!!" << endl;
}
*/

/*
// 참조에 의한 호출로 Circle 객체에 참조 전달
class Circle {
	int radius;
public:
	Circle(int radius = 1) {
		this->radius = radius;
	}
	~Circle() {};
	int getRadius() {
		return radius;
	}
	void setRadius(int radius) {
		this->radius = radius;
	}
	double getArea() {
		return 3.14 * radius * radius;
	}
};

void increaseCircle(Circle& c) {
	int r = c.getRadius();
	c.setRadius(r + 1);
}

int main() {
	Circle waffle(30);
	increaseCircle(waffle);
	cout << waffle.getRadius() << endl;
}
*/

/*
// 키보드로부터 반지름 값을 읽어 Circle 객체에 반지름을 설정하는 readRadius() 함수를 작성하라.
class Circle {
	int radius;
public:
	Circle(int radius = 1) {
		this->radius = radius;
	}
	~Circle() {};

	int getRadius() {
		return radius;
	}
	void setRadius(int radius) {
		this->radius = radius;
	}
	double getArea() {
		return 3.14 * radius * radius;
	}
};

void readRadius(Circle& c) {
	int r;
	cout << "정수 값으로 반지름을 입력하세요 : ";
	cin >> r;
	c.setRadius(r);
}

int main() {
	Circle donut;
	readRadius(donut);
	cout << donut.getRadius() << endl;
}
*/

/*
// 간단한 참조 리턴 사례
char& find(char s[], int index) {
	return s[index];
}

int main() {
	char name[] = "Mike";
	cout << name << endl;

	find(name, 0) = 'S';
	cout << name << endl;

	char& ref = find(name, 2);
	ref = 't';
	cout << name << endl;
}
*/

/*
// 객체를 함수로 전달하기
class Complex {
public :
	double real, image;
	Complex(double r = 0.0, double i = 0.0) : real{ r }, image{ i }{}
	~Complex() {}
	void print() {
		cout << real << " + " << image << "i" << endl;
	}
};

Complex add(Complex c1, Complex c2) {
	Complex temp;
	temp.real = c1.real + c2.real;
	temp.image = c1.image + c2.image;
	return temp;
}

int main() {
	Complex c1{ 1, 2 }, c2{ 3, 4 };
	Complex t;
	t = add(c1, c2);
	t.print();
	return 0;
}
*/

/*
// 복사 생성자와 객체 복사
class Circle {
	int radius;
public :
	Circle(const Circle& c); // 복사 생성자 선언
	Circle(int radius = 1) {
		this->radius = radius;
	}
	~Circle(){}
	double getArea() {
		return 3.14 * radius * radius;
	}
};

Circle::Circle(const Circle& c){ // 복사 생성자 구현
	this->radius = c.radius;
	cout << "복사 생성자 실행 radius = " << radius << endl;
}

int main() {
	Circle src(30);	// 객체의 보통 생성자 호출
	Circle dest(src); // dest 객체의 복사 생성자 호출

	cout << "원본의 면적 = " << src.getArea() << endl;
	cout << "사본의 면적 = " << dest.getArea() << endl;

	return 0;
}
*/

/*
// 깊은 복사 생성자를 가진 정상적인 Person 클래스
class Person {
	char* name;
	int id;
public :
	Person(int id, const char* name); // 생성자
	Person(const Person& person); // 복사 생성자
	~Person();
	void changeName(const char* name);
	void show() {
		cout << id << ", " << name << endl;
	}
};

Person::Person(int id, const char* name) {
	this->id = id;
	int len = strlen(name);	// name의 문자 개수
	this->name = new char[len + 1]; // name 문자열 공간 할당
	strcpy(this->name, name); // name에 문자열 복사
}

Person::Person(const Person& person) {
	this->id = person.id;	// id값 복사
	int len = strlen(person.name);	// name의 문자 개수
	this->name = new char[len + 1];	// name + \0 값까지
	strcpy(this->name, person.name);
	cout << "복사 생성자 실행, 원본 객체의 이름 : " << this->name << endl;
}

Person::~Person() {
	if (name)
		delete[] name;
}

void Person::changeName(const char* name) {
	if (strlen(name) > strlen(this->name)) {	// 현재 name에 할당된 메모리보다 긴 이름으로 바꿀 수 없다.
		return;
	}
	strcpy(this->name, name);
}

int main() {
	Person father(1, "Kitae");
	Person daughter(father);

	cout << "daughter 객체 생성 직후 -----" << endl;
	father.show();
	daughter.show();

	daughter.changeName("Grace");
	cout << "daughter 이름을 Grace로 변경한 후 -----" << endl;
	father.show();
	daughter.show();

	return 0;
}
*/

/*
// 복사 생성자가 필요한 경우 - 포인터 변수를 갖고 있을 때
class MyArray {
public :
	int size;
	int* data;
	MyArray(int size);
	MyArray(const MyArray& other);
	~MyArray();
};

MyArray::MyArray(int size) {
	this->size = size;
	data = new int[size];
}

MyArray::MyArray(const MyArray& other) {	// 깊은 복사
	this->size = other.size;
	this->data = new int[other.size];
	for (int i = 0; i < size; i++) {
		this->data[i] = other.data[i];
	}
}

MyArray::~MyArray() {
	if (data != nullptr)
		delete[] this->data;
	data = nullptr;
}
*/

/*
// has-a 관계 (상속x)
class Date {
	int year, month, day;
public :
	Date(int y, int m, int d) : year{ y }, month{ m }, day{ d }{}
	void print() {
		cout << year << "." << month << "." << day << endl;
	}
};

class Person {
	string name;
	Date birth;	// has-a 관계
public :
	Person(string n, Date d) : name{ n }, birth{ d }{}
	void print() {
		cout << name << ":";
		birth.print();
		cout << endl;
	}
};

int main() {
	Date d{ 1999, 1, 26 };
	Person p{ "신승민", d };
	p.print();
	return 0;
}
*/

/*
// 정적변수 예제
class Circle {
	int x, y;
	int radius;
public :
	static int count; // 정적 변수
	Circle() : x{0}, y{0}, radius{0}{
		count++;
	}
	Circle(int x, int y, int r) : x{ x }, y{ y }, radius{ r }{
		count++;
	}
	~Circle() {
		count--;
	}
};

int Circle::count = 0;	// 정적 변수 초기화

int main() {
	Circle c1;
	cout << "지금까지 생성된 원의 개수 : " << Circle::count << endl;

	Circle c2(100, 100, 30);
	cout << "지금까지 생성된 원의 개수 : " << Circle::count << endl;

	return 0;
}
*/

/*
// 정적 멤버 함수
class Circle {
	int x, y;
	int radius;
public:
	static int count; // 정적 변수
	Circle() : x{ 0 }, y{ 0 }, radius{ 0 }{
		count++;
	}
	Circle(int x, int y, int r) : x{ x }, y{ y }, radius{ r }{
		count++;
	}
	~Circle() {
		count--;
	}
	static int getCount() {	// 정적 멤버 함수
		return count;
	}
};

int Circle::count = 0;

int main() {
	Circle c1;
	cout << "지금까지 생성된 원의 개수 : " << Circle::getCount << endl;

	Circle c2(100, 100, 30);
	cout << "지금까지 생성된 원의 개수 : " << Circle::getCount << endl;

	return 0;
}
*/

/*
// static 멤버 사용
class Person {
public :
	int money;
	void addMoney(int money) {
		this->money += money;
	}
	static int sharedMoney;	// 공금
	static void addShared(int n) {
		sharedMoney += n;
	}
};

// static 변수 생성. 전역 공간에 생성
int Person::sharedMoney = 10; // 10으로 초기화

int main() {
	Person han;
	han.money = 100;
	han.sharedMoney = 200;

	Person lee;
	lee.money = 150;
	lee.addMoney(200);
	lee.addShared(200);

	cout << han.money << " " << lee.money << endl;
	cout << han.sharedMoney << " " << lee.sharedMoney << endl;

	return 0;
}
*/

/*
// static 멤버를 공유의 목적으로 사용하는 예
// static 멤버 함수는 static 멤버 변수만 접근 가능!!
// 하지만 non-static 멤버 함수는 static에 접근 가능!!!!!!!!
// 즉, static멤버 변수는 공용으로 사용하기에 어떠한 함수도 쓸 수 있다!!! (하지만, static 멤버함수는 this, non-static 멤버 변수 사용X)
class Circle {
	static int numOfCircles;
	int radius;
public :
	Circle(int r = 1);
	~Circle() {
		numOfCircles--;
	}
	double getArea() {
		return 3.14 * radius * radius;
	}
	static int getNumOfCircles() {
		return numOfCircles;
	}
};

Circle::Circle(int r) {
	radius = r;
	numOfCircles++;
}

int Circle::numOfCircles = 0;

int main() {
	Circle* p = new Circle[10];
	cout << "생존하고 있는 원의 개수 : " << Circle::getNumOfCircles() << endl;

	delete[] p;
	cout << "생존하고 있는 원의 개수 : " << Circle::getNumOfCircles() << endl;

	Circle a;
	cout << "생존하고 있는 원의 개수 : " << Circle::getNumOfCircles() << endl;

	Circle b;
	cout << "생존하고 있는 원의 개수 : " << Circle::getNumOfCircles() << endl;

	return 0;
}
*/

// 8강 연산자중복과 프렌드 함수 ---------------------------------------------------------------------------------------------------
/*
// 두 개의 Power 객체를 더하는 + 연산자 작성
class Power {
	int kick;
	int punch;
public:
	Power(int kick = 0, int punch = 0) {
		this->kick = kick;
		this->punch = punch;
	}
	~Power() {}
	void show();
	Power operator+(Power op2); // 연산자 함수 선언
};

void Power::show() {
	cout << "kick = " << kick << ", " << "punch = " << punch << endl;
}

Power Power::operator+(Power op2) {
	Power tmp;
	tmp.kick = this->kick + op2.kick;
	tmp.punch = this->punch + op2.punch;
	return tmp;
}

int main() {
	Power a(3, 5), b(4, 6), c;
	c = a + b;
	a.show();
	b.show();
	c.show();

	return 0;
}
*/

/*
// 두 개의 Power 객체를 비교하는 == 연산자 작성
class Power {
	int kick;
	int punch;
public:
	Power(int kick = 0, int punch = 0) {
		this->kick = kick;
		this->punch = punch;
	}
	~Power() {}
	void show();
	bool operator == (Power op2);
};

void Power::show() {
	cout << "kick = " << kick << ", " << "punch = " << punch << endl;
}

bool Power::operator==(Power op2) {
	if (kick == op2.kick && punch == op2.punch)
		return true;
	else
		return false;
}

int main() {
	Power a(3, 5), b(3, 5);
	a.show();
	b.show();
	if (a == b)
		cout << "두 파워가 같다." << endl;
	else
		cout << "두 파워가 다르다." << endl;

	return 0;
}
*/

/*
// 두 Power 객체를 더하는 += 연산자 작성
class Power {
	int kick;
	int punch;
public:
	Power(int kick = 0, int punch = 0) {
		this->kick = kick;
		this->punch = punch;
	}
	~Power() {}
	void show();
	Power& operator+=(Power op2);
};

void Power::show() {
	cout << "kick = " << kick << ", " << "punch = " << punch << endl;
}

Power& Power::operator+=(Power op2) {	// 타입이 참조 이므로
	kick = kick + op2.kick;
	punch = punch + op2.punch;
	return *this;	// 리턴을 주소 값을 준다
}

int main() {
	Power a(3, 5), b(4, 6), c;
	a.show();
	b.show();
	c = a += b;
	a.show();
	c.show();

	return 0;
}
*/

/*
// + 연산자 작성(실습) : b = a + 2
class Power {
	int kick;
	int punch;
public:
	Power(int kick = 0, int punch = 0) {
		this->kick = kick;
		this->punch = punch;
	}
	~Power() {}
	void show();
	Power operator+(int op2);
};

void Power::show() {
	cout << "kick = " << kick << ", " << "punch = " << punch << endl;
}

Power Power::operator+(int op2) {
	Power tmp;
	tmp.kick = kick + op2;
	tmp.punch = punch + op2;
	return tmp;
}

int main() {
	Power a(3, 5), b;
	a.show();
	b.show();
	b = a + 2;
	a.show();
	b.show();

	return 0;
}
*/

/*
// operator + 예제
class MyVector {
	double x, y;
public :
	MyVector(double x = 0.0, double y = 0.0) : x{x}, y{y}{}
	string to_String() {
		return "(" + to_string(x) + ", " + to_string(y) + ")";
	}
	MyVector operator+(const MyVector& v2);
};

MyVector MyVector::operator+(const MyVector& v2) {
	MyVector v;
	v.x = this->x + v2.x;
	v.y = this->y + v2.y;
	return v;
}

int main() {
	MyVector v1(1.0, 2.0), v2(3.0, 4.0);
	MyVector v3 = v1 + v2;

	cout << v1.to_String() << " + " << v2.to_String() << " = " << v3.to_String() << endl;

	return 0;
}
*/

/*
// ==, != 연산자의 중복
class Time {
	int hour, min, sec;
public :
	Time(int h = 0, int m = 0, int s = 0) : hour{ h }, min{ m }, sec{ s }{}
	bool operator==(Time& t2) {
		return (hour == t2.hour && min == t2.min && sec == t2.sec);
	}
	bool operator != (Time& t2) {	// != 연산자
		return !(*this == t2);
	}
};

int main() {
	Time t1(1, 2, 3), t2(1, 2, 3);

	cout.setf(cout.boolalpha);
	cout << (t1 == t2) << endl;
	cout << (t1 != t2) << endl;
	
	return 0;
}
*/

/*
// 전위 ++ 연산자 작성
class Power {
	int kick;
	int punch;
public:
	Power(int kick = 0, int punch = 0) {
		this->kick = kick;
		this->punch = punch;
	}
	~Power() {}
	void show();
	Power& operator++();
};

void Power::show() {
	cout << "kick = " << kick << ", " << "punch = " << punch << endl;
}

Power& Power::operator++() {
	kick++;
	punch++;
	return *this;
}

int main() {
	Power a(3, 5), b;
	a.show();
	b.show();
	b = ++a;
	a.show();
	b.show();

	return 0;
}
*/

/*
// !연산자를 Power클래스의 멤버 함수로 작성
// !a는 a의 kick, punch 파워가 모두 0이면 true, 아니면 false를 리턴한다.
class Power {
	int kick;
	int punch;
public:
	Power(int kick = 0, int punch = 0) {
		this->kick = kick;
		this->punch = punch;
	}
	~Power() {}
	void show();
	bool operator!();
};

void Power::show() {
	cout << "kick = " << kick << ", " << "punch = " << punch << endl;
}

bool Power::operator!() {
	if (kick == 0 && punch == 0)
		return true;
	else
		return false;
}

int main() {
	Power a(0, 0), b(5, 5);
	if (!a)
		cout << "a의 파워가 0 이다" << endl;
	else
		cout << "a의 파워가 0이 아니다" << endl;
	if (!b)
		cout << "b의 파워가 0이다" << endl;
	else
		cout << "b의 파워가 0이 아니다" << endl;

	return 0;
}
*/

/*
// ++ 연산자의 중복
class Counter {
	int value;
public :
	Counter() : value{ 0 } {  };
	~Counter() {}
	int getValue()const {
		return value;
	}
	void setValue(int x) {
		value = x;
	}
	Counter& operator++() {	// 전위 ++ 연산자
		++value;
		return *this;
	}
};

int main() {
	Counter c;
	cout << "카운터의 값 : " << c.getValue() << endl;
	++c;
	cout << "카운터의 값 : " << c.getValue() << endl;

	return 0;
}
*/

/*
// 후위 ++ 연산자 작성
class Power {
	int kick;
	int punch;
public:
	Power(int kick = 0, int punch = 0) {
		this->kick = kick;
		this->punch = punch;
	}
	~Power() {}
	void show();
	Power operator++(int x);
};

void Power::show() {
	cout << "kick = " << kick << ", " << "punch = " << punch << endl;
}

Power Power::operator++(int x) {
	Power tmp = *this;
	kick++;
	punch++;
	return tmp;
}

int main() {
	Power a(3, 5), b;
	a.show();
	b.show();
	b = a++;	// 넣고 증가
	a.show();
	b.show();

	return 0;
}
*/

/*
// 참조를 리턴하는 << 연산자 작성
// Power 객체의 kick과 punch에 정수를 더하는 << 연산자를 멤버 함수로 작성하라
class Power {
	int kick;
	int punch;
public:
	Power(int kick = 0, int punch = 0) {
		this->kick = kick;
		this->punch = punch;
	}
	~Power() {}
	void show();
	Power& operator <<(int n);
};

void Power::show() {
	cout << "kick = " << kick << ", " << "punch = " << punch << endl;
}

Power& Power::operator <<(int n) {
	kick += n;
	punch += n;
	return *this;
}

int main() {
	Power a(1, 2);
	a << 3 << 5 << 6;
	a.show();
}
*/

/*
// 대입 연산자 중복
class Box {
	double length, width, height;
public :
	Box(double l = 0.0, double w = 0.0, double h = 0.0) : length{ l }, width{ w }, height{ h }{}
	void display() {
		cout << "(" << length << ", " << width << ", " << height << ")" << endl;
	}
	Box& operator =(const Box& b2) {
		this->length = b2.length;
		this->width = b2.width;
		this->height = b2.height;
		return *this;
	}
 };

int main() {
	Box b1(30.0, 30.0, 60.0), b2;
	b1.display();

	b2 = b1;
	b2.display();

	return 0;
}
*/

/*
// 인덱스 연산자 []의 중복
const int SIZE = 10;

class MyArray {
	int a[SIZE];
public :
	MyArray() {
		for (int i = 0; i < SIZE; i++)
			a[i] = 0;
	}
	int& operator[](int i) {
		if (i >= SIZE) {
			cout << "잘못된 인덱스 : ";
			return a[0];
		}
		return a[i];
	}
};

int main() {
	MyArray A;

	A[3] = 9;
	cout << "A[3] = " << A[3] << endl;
	cout << "A[16] = " << A[16] << endl;

	return 0;
}
*/

/*
// 포인터 연산자의 중복
class Pointer {
	int* p;
public :
	Pointer(int*p):p{p}{}
	~Pointer() { delete p; }
	int* operator->()const {
		return p;
	}
	int& operator*()const {	// 정수형 이기 때문에 *연산자만 테스트
		return *p;
	}
};

int main() {
	Pointer p(new int);

	*p = 100;
	cout << *p << endl;
	return 0;
}
*/

/*
// 프렌드 함수 만들기
class Rect; // Rect 클래스가 선언되기 전에 먼저 참조되는 컴파일 오류를 막기 위한 선언문
bool equals(Rect r, Rect s); // equals() 함수 선언
class Rect {
	int width, height;
public :
	Rect(int width, int height) {
		this->width = width;
		this->height = height;
	}
	friend bool equals(Rect r, Rect s);
};

bool equals(Rect r, Rect s) {
	if (r.width == s.width && r.height == s.height)	// private 송성을 가진 변수에 접근 가능
		return true;
	else
		return false;
}

int main() {
	Rect a(3, 4), b(4, 5);
	if (equals(a, b))
		cout << "equal!" << endl;
	else
		cout << "Not equal!!" << endl;
}
*/

/*
// 다른 클래스의 멤버 함수를 프렌드로 선언
class Rect;

class RectManager {
public :
	bool equals(Rect r, Rect s);
};

class Rect {
	int width, height;
public :
	Rect(int width, int height) {
		this->width = width;
		this->height = height;
	}
	friend bool RectManager::equals(Rect r, Rect s);
};

bool RectManager::equals(Rect r, Rect s) {
	if (r.width == s.width && r.height == s.height)
		return true;
	else
		return false;
}

int main() {
	Rect a(3, 4), b(3, 4);
	RectManager man;

	if (man.equals(a, b))
		cout << "Equal!!" << endl;
	else
		cout << "Not equal!" << endl;

	return 0;
}
*/

/*
// 다른 클래스 전체를 프렌드로 선언
class Rect;

class RectManager {
public:
	bool equals(Rect r, Rect s);
	void copy(Rect& dest, Rect& src);
};

class Rect {
	int width, height;
public:
	Rect(int width, int height) {
		this->width = width;
		this->height = height;
	}
	friend RectManager;
};

bool RectManager::equals(Rect r, Rect s) {
	if (r.width == s.width && r.height == s.height)
		return true;
	else
		return false;
}

void RectManager::copy(Rect& dest, Rect& src) {
	dest.width = src.width;
	dest.height = src.height;
}

int main() {
	Rect a(3, 4), b(5, 6);
	RectManager man;

	man.copy(b, a);
	if (man.equals(a, b))
		cout << "Equal!!" << endl;
	else
		cout << "Not equal!" << endl;

	return 0;
}
*/

/*
// << 연산자의 중복 정의 - Ostream안의 멤버함수임 따라서 friend함수여야 중복 정의할 수 있음
// friend ostream& operator<<(ostream& os, const MyVector& v) -> &는 <<연산자를 연속적으로 사용하기 위함
class MyVector {
	double x, y;
public :
	MyVector(double xvalue = 0.0, double yvalue = 0.0) : x{ xvalue }, y{ yvalue }{}
	friend ostream& operator<<(ostream& os, const MyVector& v) {
		os << "(" << v.x << ", " << v.y << ")" << endl;
		return os;
	}
};

int main() {
	MyVector v1(1.0, 2.0), v2(3.0, 4.0), v3;
	cout << v1 << v2 << v3;
	return 0;
}
*/

/*
// 2+a를 위한 +연산자 함수를 프렌드로 작성
class Power {
	int kick;
	int punch;
public:
	Power(int kick = 0, int punch = 0) {
		this->kick = kick;
		this->punch = punch;
	}
	~Power() {}
	void show();
	friend Power operator+(int op1, Power op2);
};

void Power::show() {
	cout << "kick = " << kick << ", " << "punch = " << punch << endl;
}

Power operator+(int op1, Power op2) {
	Power tmp;
	tmp.kick = op1 + op2.kick;
	tmp.punch = op1 + op2.punch;
	return tmp;
}

int main() {
	Power a(3, 5), b;
	a.show();
	b.show();
	b = 2 + a;
	a.show();
	b.show();
}
*/

/*
// a + b를 위한 연산자 함수를 프렌드로 작성
class Power {
	int kick;
	int punch;
public:
	Power(int kick = 0, int punch = 0) {
		this->kick = kick;
		this->punch = punch;
	}
	~Power() {}
	void show();
	friend Power operator+(Power op1, Power op2);
};

void Power::show() {
	cout << "kick = " << kick << ", " << "punch = " << punch << endl;
}

Power operator+(Power op1, Power op2) {
	Power tmp;
	tmp.kick = op1.kick + op2.kick;
	tmp.punch = op1.punch + op2.punch;
	return tmp;
}

int main() {
	Power a(3, 5), b(4, 6), c;
	c = a + b;
	a.show();
	b.show();
	c.show();
}
*/

/*
// ++ 연산자를 프렌드로 작성한 예
class Power {
	int kick;
	int punch;
public:
	Power(int kick = 0, int punch = 0) {
		this->kick = kick;
		this->punch = punch;
	}
	~Power() {}
	void show();
	friend Power& operator++(Power& op);	// 전위++
	friend Power operator++(Power& op, int x); // ++후위, int x 는 전위 연산자와 구분하기 위해 0의 의미없는 값을 넣는다.
};

void Power::show() {
	cout << "kick = " << kick << ", " << "punch = " << punch << endl;
}

Power& operator++(Power& op) {
	op.kick++;
	op.punch++;
	return op;
}

Power operator++(Power& op, int x) {
	Power tmp = op;
	op.kick++;
	op.punch++;
	return tmp;	// 변경 전의 op리턴
}

int main() {
	Power a(3, 5), b;
	b = ++a;
	a.show();
	b.show();
	b = a++;
	a.show();
	b.show();
}
*/

/*
// 연산자 실습
class Power {
	int kick;
	int punch;
public:
	Power(int kick = 0, int punch = 0) {
		this->kick = kick;
		this->punch = punch;
	}
	~Power() {}
	void show();
	Power& operator++();
	Power& operator++(int a);
	friend Power operator+(Power op1, Power op2);
	bool operator==(Power op2);
	friend ostream& operator<<(ostream& os, Power op2);
};

void Power::show() {
	cout << "kick = " << kick << ", " << "punch = " << punch << endl;
}

Power& Power::operator++(){
	kick++;
	punch++;
	return *this;
}

Power& Power::operator++(int a){
	Power tmp = *this;
	this->kick = kick;
	this->punch = punch;
	return tmp;
}

Power operator+(Power op1, Power op2){
	Power tmp;
	tmp.kick = op1.kick + op2.kick;
	tmp.punch = op1.punch + op2.punch;
	return tmp;
}

bool Power::operator==(Power op2){
	return kick == op2.kick && punch == op2.punch;
}

// 왜 안되지?
//bool Power::operator==(Power op2) {
//	if (kick == op2.kick && punch == op2.punch)
//		return true;
//	else
//		false;
//}


ostream& operator<<(ostream& os, Power op2) {
	os << "[ " << op2.kick << ", " << op2.punch << " ]";
	return os;
}

int main() {
	Power a(3, 4), b(4, 6), c;
	c = a++;
	cout << a << ", " << b << ", " << c << endl;
	c = ++b;
	cout << a << ", " << b << ", " << c << endl;
	c = a + b;
	cout << c << endl;
	if (a == b)
		cout << "power 같다.";
	else
		cout << "power 같지 않다.";
}
*/

// 9강 상속 --------------------------------------------------------------------------------------------------------------------------------------

// 상속의 표현 -> 자식 클래스 : public 부모 클래스

/*
// Point 클래스를 상속받는 ColorPoint 클래스 만들기
class Point {
	int x, y;
public :
	void set(int x, int y) {
		this->x = x;
		this->y = y;
	}
	void showPoint() {
		cout << "(" << x << ", " << y << ")" << endl;
	}
};

class ColorPoint : public Point {
	string color;
public :
	void setColor(string color) {
		this->color = color;
	}
	void showColorPoint() {
		cout << color << " : ";
		showPoint();
	}
};

int main() {
	Point p;
	ColorPoint cp;
	cp.set(3, 4);
	cp.setColor("red");
	cp.showColorPoint();
}
*/

/*
// 상속 예제 (자동차 - 스포츠카)
class Car {
	int speed;
public :
	void setSpeed(int s) {
		this -> speed = s;
	}
	int getSpeed() {
		return speed;
	}
	void show() {
		cout << "speed : " << speed << endl;
	}
};

class SportsCar : public Car {
	bool turbo;
public :
	void setTurbo(bool newValue) {
		this->turbo = newValue;
	}
	bool getTurbo() {
		return turbo;
	}
	void show2() {
		show();
		cout << "turbo : " << boolalpha << turbo << endl;
	}
};

int main() {
	SportsCar c;

	c.setSpeed(60);
	c.setTurbo(true);
	c.show2();
	c.setSpeed(100);
	c.setTurbo(false);
	c.show2();
	return 0;
}
*/

/*
// 접근자 예제
class Person {
	string name;
protected :	// 자식 클래스에서 접근 가능
	string address;
};

class Student : Person {
public :
	void setAddress(string add) {
		address = add;
	}
	string getAddress() {
		return address;
	}
};

int main() {
	Student obj;

	obj.setAddress("서울시 종로구 1번지");
	cout << obj.getAddress() << endl;

	return 0;
}
*/

/*
// 부모 클래스의 멤버함수 호출
class ParentClass {
public :
	void print() {
		cout << "부모 클래스의 print() 멤버 함수" << endl;
	}
};

class ChildClass : public ParentClass {
	int data;
public :
	void print() {	//  멤버함수 재정의 -> 같으니까
		ParentClass::print();
		cout << "자식 클래스의 print() 멤버 함수" << endl;
	}
};
*/

/*
// Sprite - Alien - Player ex
class Sprite {
	int x, y;
	string image;
public :
	Sprite(int x, int y, string image) :x{ x }, y{ y }, image{ image }{}
	void draw();
	void move();
};

class Alien : public Sprite {
	int speed;
public:
	Alien(int x, int y, string image) : Sprite{x, y, image} {}
	void move() {}
};

class Player : public Sprite {
	string name;
public :
	Player(int x, int y, string image) : Sprite{ x, y, image } {}
	void move();
};

int main() {
	Alien(0, 100, "imagel.jpg");
	Player p{ 0,100, "image1.jpg" };
	return 0;
}
*/

/*
// 다중 상속 -> 하나의 자식 클래스가 두개 이상의 부모 클래스로부터 멤버를 상속받는 것을 의미
// ex) class 자식 : 부모, 부모
class PassangerCar {
public :
	int seats;
	void set_seats(int n) {
		seats = n;
	}
};

class Truck {
public :
	int payload;
	void set_payload(int load) {
		payload = load;
	}
};

class Pickup : public PassangerCar, public Truck {
public :
	int tow_capability;
	void set_tow(int capa) {
		tow_capability = capa;
	}
};

int main() {
	Pickup my_car;
	my_car.set_seats(4);
	my_car.set_payload(10000);
	my_car.set_tow(30000);
	return 0;
}
*/

/*
// 업 캐스팅 -> 사람을 동물로 보는 것 -> 자식 클래스가 부모 클래스에 들어가는 것
// 다운 캐스팅 -> 부모 클래스가 자식클래스에 들어가는 것
int main() {
	ColorPoint cp;	// 객체생성
	ColorPoint* pDer = &cp;	// 자식클래스 타입으로 cp처음 시작 주소값 가리킴
	Point* pBase = pDer;	// 부모클래스 타입에 자식클래스 타입을 대입	// 업 캐스팅

	pDer = (ColorPoint *)pBase; // 다운 캐스팅
}
*/

/*
// protected 멤버에 대한 접근
class Point {
protected :
	int x, y;
public :
	void set(int x, int y);
	void showPoint();
};

void Point::set(int x, int y) {
	this->x = x;
	this->y = y;
}

void Point::showPoint() {
	cout << "(" << x << ", " << y << ")" << endl;
}

class ColorPoint : public Point {
	string color;
public :
	void setColor(string color);
	void showColorPoint();
	bool equals(ColorPoint p);
};

void ColorPoint::setColor(string color) {
	this->color = color;
}

void ColorPoint::showColorPoint() {
	cout << color << ": ";
	showPoint();
}

bool ColorPoint::equals(ColorPoint p) {
	if (x == p.x && y == p.y && color == p.color)	// protected : 상속받은 클래스 사용 가능
		return true;
	else
		return false;
}

int main() {
	Point p;
	p.set(2, 3);	// ok
	//p.x = 5; // eroor
	//p.y = 5; // error
	p.showPoint();

	ColorPoint cp;
	//cp.x = 10; // error
	//cp,y = 10; // error
	cp.set(3, 4);
	cp.setColor("red");
	cp.showColorPoint();

	ColorPoint cp2;
	cp2. set(3, 4);
	cp2.setColor("red");
	cout << ((cp.equals(cp2)) ? "true" : "false");	// ok
}
*/

/*
// 다중 상속 선언 및 멤버 호출
class MP3 {
public :
	void play();
	void stop();
};

class MobilePhone {
public :
	bool sendCall();
	bool receiveCall();
	bool sendSMS();
	bool receiveSMS();
};

class MusicPhone : public MP3, public MobilePhone {	// 다중 상속 선언
public :
	void dial();
};

void MusicPhone::dial() {	// 다중 상속 활용
	play();
	sendCall();
}

int main() {	// 다중 상속 활용
	MusicPhone hanPhone;
	hanPhone.play();
	hanPhone.sendSMS();
}
*/

/*
// Adder와 Subtractor를 다중 상속 받는 Calculator 클래스 작성
class Adder {
protected :
	int add(int a, int b) {
		return a + b;
	}
};

class Subtractor {
protected :
	int minus(int a, int b) {
		return a - b;
	}
};

class Calculator : public Adder, public Subtractor {
public :
	int calc(char op, int a, int b);
};

int Calculator::calc(char op, int a, int b) {
	int res = 0;
	switch (op) {
	case '+': res = add(a, b); break;
	case '-': res = minus(a, b); break;
	}
	return res;
}

int main() {
	Calculator handCaculator;
	cout << "2 + 4 = " << handCaculator.calc('+', 2, 4) << endl;
	cout << "100 - 8 = " << handCaculator.calc('-', 100, 8) << endl;
	return 0;
}
*/

/*
// 가상 상속 virtual로 다중 상속의 모호성 해결 ( 컴파일x   런타임에서 확인 )  
class BaseIO {
public :
	int mode;
};

class In : virtual public BaseIO {
public : 
	int readPos;
};

class Out : virtual public BaseIO {
public :
	int writePos;
};

class InOut : public In, public Out {
public :
	bool safe;
};

int main() {
	InOut ioObj;

	ioObj.readPos = 10;
	ioObj.writePos = 20;
	ioObj.safe = true;
	ioObj.mode = 5;			// 모호성 해결
}
*/

/*
// 상속 실습 1
class TV {
	int size;
public :
	TV() {
		size = 20;
	}
	TV(int size) {
		this->size = size;
	}
	int getSize() {
		return size;
	}
};

class WideTV : public TV {
	bool videoIn;
public :
	WideTV(int size, bool videoIn) :TV(size) {	// 부모 클래스에 있는 생성자 호출, 없으면 부모 클래스 기본 생성자 호출됨
		this->videoIn = videoIn;
	}
	bool getVideoIn() {
		return videoIn;
	}
};

class SmartTV : public WideTV {
	string ipAddr;
public :
	SmartTV(string ipAddr, int size) : WideTV(size, true) {
		this->ipAddr = ipAddr;
	}
	string getIp() {
		return ipAddr;
	}
};

int main() {
	SmartTV tv("192.0.0.1", 32);
	cout << "size = " << tv.getSize() << endl;
	cout << "videoin = " << boolalpha << tv.getVideoIn() << endl;
	cout << "ip = " << tv.getIp() << endl;
}
*/

/*
// 상속 실습 2
class Shape {
	int x, y;
public :
	Shape(int x = 0, int y = 0) : x{ x }, y{ y }{}
	void setX(int x) {
		this->x = x;
	}
	void setY(int y) {
		this->y = y;
	}
	int getX() {
		return x;
	}
	int getY() {
		return y;
	}
	void draw() {
		cout << "Sahpe drawing ......" << endl;
	}
	int getArea() {
		return 0;
	}
};

class Circle : public Shape {
	int r;
public :
	Circle(int r, int x, int y) : Shape(x, y), r{r}{}
	void draw() {
		cout << "Circle drawing ......" << endl;
	}
	double getArea() {	// 재정의? 중복정의? -> 재정의!! Overriding
		return 3.14 * r* r;
	}
};

class Rect : public Shape {
	int w, h;
public :
	Rect(int x, int y, int w, int h) : Shape(x, y), w{ w }, h{ h }{}
	void draw() {
		cout << "Rectangle drawing ....." << endl;
	}
	int getArea() {
		return w * h;
	}
};

int main() {
	Circle c(10, 1, 1);
	Rect r(1, 1, 10, 20);
	c.draw();
	r.draw();
	cout << c.getArea() << endl;
	cout << r.getArea() << endl;
}
*/

// 10강 다형성 -------------------------------------------------------------------------------------------------
/*
// 파생 클래스에서 함수를 재정의 하는 사례
class Base {
public :
	void f() {
		cout << "Base::f() called" << endl;
	}
};

class Derived : public Base {
public :
	void f() {
		cout << "Derived::f() called" << endl;
	}
};

void main() {
	Derived d, * pDer;
	pDer = &d;
	pDer->f();	// Derived::f() 호출

	Base* pBase;
	pBase = pDer;	// 업캐스팅
	pBase->f();	//Base::f() 호출
}
*/

/*
// 함수 재정의와 오버라이딩 사례 비교
// Redefine
class Base {
public :
	void f() {
		cout << "Base::f() called" << endl;
	}
};

class Derived : public Base {
public :
	void f() {
		cout << "Derived::f() called" << endl;
	}
};

// overriding
class Base {
public:
	virtual void f() {
		cout << "Base::f() called" << endl;
	}
};

class Derived : public Base {
public:
	virtual void f() {
		cout << "Derived::f() called" << endl;
	}
};
*/

/*
// 오버라이딩과 가상 함수 호출
class Base {
public:
	virtual void f() {
		cout << "Base::f() called" << endl;
	}
};

class Derived : public Base {
public:
	virtual void f() {
		cout << "Derived::f() called" << endl;
	}
};

int main() {
	Derived d, * pDer;
	pDer = &d;
	pDer->f();	// Derived::f() 호출

	Base* pBase;
	pBase = pDer;	// upcasting
	pBase->f();	// 동적바인딩 발생 Derived::f() 실행
}
*/

/*
// Pure virtual function Ex
class Date {
protected :
	int year, month, day;
public :
	Date(int y, int m, int d) : year{ y }, month{ m }, day{ d }{}
	virtual void print() = 0;	// pure virtual function
};

class Adate : public Date {
public :
	Adate(int y, int m, int d) : Date(y, m, d) {}
	void print() {
		cout << year << "." << month << "." << day << ".\n";
	}
};

class Bdate : public Date {
public :
	Bdate(int y, int m, int d) : Date(y, m, d) {}
	void print();
};

void Bdate::print() {
	static const char* mn[] = { "Jan", "Feb", "Mar", "Apr" };
	cout << mn[month - 1] << " " << day << ' ' << year << endl;
}

int main() {
	Adate a(1999, 1, 26);
	Bdate b(2000, 2, 13);
	Date& r1 = a, & r2 = b;
	r1.print();
	r2.print();
	return 0;
}
*/

/*
// 추상 클래스 구현 연습
class Calculator {
public :
	virtual int add(int a, int b) = 0;
	virtual int substract(int a, int b) = 0;
	virtual double average(int a[], int size) = 0;
};

class GoodCalc : public Calculator {
	int add(int a, int b) {
		return a + b;
	}
	int substract(int a, int b) {
		return a - b;
	}

	double average(int a[], int size) {
		double sum = 0;
		for (int i = 0; i < size; i++) {
			sum += a[i];
		}
		return sum / size;
	}
};

int main() {
	int a[] = { 1, 2, 3, 4, 5 };
	Calculator* p = new GoodCalc;
	cout << p->add(2, 3) << endl;
	cout << p->substract(2, 3) << endl;
	cout << p->average(a, 5) << endl;
	delete p;
}
*/

/*
// 추상 클래스를 상속받는 파생 클래스 구현 연습
class Calculator {
	void input() {
		cout << "정수 2개를 입력하세요 : ";
		cin >> a >> b;
	}
protected:
	int a, b;
	virtual int calc(int a, int b) = 0;
public :
	void run() {
		input();
		cout << "계산된 값은 " << calc(a, b) << endl;
	}
};

class Adder : public Calculator {
protected :
	int calc(int a, int b) {
		return a + b;
	}
};

class Subtractor : public Calculator {
protected :
	int calc(int a, int b) {
		return a - b;
	}
};

int main() {
	Adder adder;
	Subtractor subtractor;
	adder.run();
	subtractor.run();
}
*/

/*
// Virtual 소멸자 필요성 예 - run 안됨
class AAA {
	char* str1;
public :
	AAA(char* _str1) {
		str1 = new char[strlen(_str1) + 1];
		strcpy(str1, _str1);
	}
	virtual ~AAA() {
		cout << "~AAA() call!!" << endl;
		delete[] str1;
	}
	virtual void ShowString() {
		cout << str1 << " ";
	}
};

class BBB : public AAA {
	char* str2;
public :
	BBB(char* _str1, char* _str2) : AAA(_str1) {
		str2 = new char[strlen(_str2) + 1];
		strcpy(str2, _str2);
	}
	~BBB() {
		cout << "~BBB() call!!" << endl;
		delete[] str2;
	}
	virtual void ShowString() {
		AAA::ShowString();
		cout << str2 << endl;
	}
};

int main() {
	AAA* a = new BBB("Good", "evening");
	BBB* b = new BBB("Good", "morning");
	a->ShowString();
	b->ShowString();
	cout << "-----객체 소멸 직전-----" << endl;
	delete a;
	delete b;
	return 0;
}
*/

/*
// 소멸자 문제 예제 - error
class String {
	char* s;
public :
	String(char* p) {
		cout << "String() 생성자" << endl;
		s = new char[strlen(p) + 1];
		strcpy(s, p);
	}
	virtual ~String() {
		cout << "String() 소멸자" << endl;
		delete[] s;
	}
	virtual void display() {
		cout << s;
	}
};

class MyString : public String {
	char* header;
public :
	MyString(char* h, char* p) : String(p) {
		cout << "MyString() 생성자" << endl;
		header = new char[strlen(h) + 1];
		strcpy(header, h);
	}
	~MyString() {
		cout << "MyString() 소멸자" << endl;
		delete[] header;
	}
	void display() {
		cout << header;
		String::display();
		cout << header << endl;
	}
};

int main() {
	String* p = new MyString("---", "Hello World!");
	p->display();
	delete p;

	return 0;
}
*/

/*
// 다형성 실습
class Converter {	// 추상 클래스 포인터는 만들 수 있다 But 객체 생성 불가능
protected :
	double ratio;
	virtual double convert(double src) = 0;
	virtual string getSourceString() = 0;
	virtual string getDestString() = 0;
public :
	Converter(double ratio) {
		this->ratio = ratio;
	}
	void run() {
		double src;
		cout << getSourceString() << "을 " << getDestString() << "로 바꿉니다." << endl;
		cout << getSourceString() << "을 입력하세요 : ";
		cin >> src;
		cout << "변환결과 : " << convert(src) << getDestString() << endl;
	}
};

class WonToDollar : public Converter {
protected:
	virtual double convert(double src) {
		return src / ratio;
	}
	virtual string getSourceString() {
		return "원";
	}
	virtual string getDestString() {
		return "달러";
	}
public :
	WonToDollar(double ratio) : Converter(ratio) {	}
};

class KmToMile : public Converter {
protected:
	virtual double convert(double src) {
		return src / ratio;
	}
	virtual string getSourceString() {
		return "Km";
	}
	virtual string getDestString() {
		return "Mile";
	}
public :
	KmToMile(double ratio) : Converter(ratio) {}
};

int main() {
	WonToDollar wd(1010);
	KmToMile toMile(1.6039344);
	//wd.run();
	//toMile.run();

	Converter* p;
	p = &wd;
	p->run();
	p = &toMile;
	p->run();
}
*/

// 11강 예외처리와 템플릿 ----------------------------------------------------------------------------------------
/*
// try - throw - catch 예제
int main() {
	int pizza_slices = 0;
	int persons = -1;
	int slices_per_person = 1;
	try{
		cout << "피자 조각수를 입력하시오 : ";
		cin >> pizza_slices;
		cout << "사람 수를 입력하시오 : ";
		cin >> persons;
		if(persons == 0){
			throw persons;
		}
		slices_per_person = pizza_slices / persons;
		cout << "한 사람 당 피자는 " << slices_per_person << "입니다." << endl;
	} catch(int e){
		cout << "사람이 " << e << "명 입니다." << endl;
	}
	return 0;
}
*/

/*
// 두 개의 정수를 입력받아 나누기 예외처리
int divide(int a, int b);
int main() {
	int a, b;
	cout << "두개의 숫자 입력 : ";
	cin >> a >> b;
	try {
		cout << "a/b의 몫 : " << divide(a, b) << endl;
	}
	catch (int exception) {
		cout << exception << "입력." << endl;
		cout << "입력 오류! 다시 실행 하세요." << endl;
	}
	return 0;
}

int divide(int a, int b) {
	if (b == 0)
		throw b;
	return a / b;
}
*/

/*
// 문자열을 정수로 변환하기
// 정수로 변환할 수 없는 문자열의 경우 예외 처리하라.
int stringToInt(const char x[]) {
	int sum = 0;
	int len = strlen(x);
	for (int i = 0; i < len; i++) {
		if (x[i] >= '0' && x[i] <= '9')
			sum = sum * 10 + x[i] - '0';
		else
			throw x;	// char* 타입의 예외 발생
	}
	return sum;
}

int main() {
	int n;
	try {
		n = stringToInt("123");	// 문자열을 정수로 변환
		cout << "\"123\" 은 정수" << n << "로 변환됨" << endl;
		n = stringToInt("1A3"); // 문자열을 정수로 변환
		cout << "\"1A3\" 은 정수" << n << "로 변환됨" << endl;
	}
	catch (const char* s) {
		cout << s << "처리에서 예외 발생!!" << endl;
		return 0;
	}
}
*/

/*
// 예외 처리를 가진 스택 클래스 만들기
#ifndef MYSTACK_H
#define MYSTACK_H

class MyStack {
	int data[100];
	int tos;
public :
	MyStack() {
		tos = -1;
	}
	void push(int n) throw(char*);
	int pop() throw(char*);
};

#endif

void MyStack::push(int n) {
	if (tos == 99)
		throw "Stack Full";
	tos++;
	data[tos] = n;
	cout << "push : " << data[tos] << endl;
}

int MyStack::pop() {
	if (tos == -1)
		throw "Stack Empty";
	int rData = data[tos--];
	cout << "pop : ";
	return rData;
}

int main() {
	MyStack intStack;
	try {
		intStack.push(100);
		intStack.push(200);
		cout << intStack.pop() << endl;
		cout << intStack.pop() << endl;
		cout << intStack.pop() << endl;	// 예외 발생! 
	}
	catch(const char* s){
		cout << "예외 발생 : " << s << endl;
	}
}
*/

/*
// 예외 클래스 만들기
class MyException {
	int lineNo;
	string func, msg;
public :
	MyException(int n, string f, string m) {
		lineNo = n;
		func = f;
		msg = m;
	}
	void print() {
		cout << func << " : " << lineNo << ", " << msg << endl;
	}
};

class DivideByZeroException : public MyException {
	// 0으로 나누는 예외 클래스 선언
public :
	DivideByZeroException(int lineNo, string func, string msg) : MyException(lineNo, func, msg) {}
};

class InvalidinputException : public MyException {
	// 잘못된 입력 예외 클래스 선언
public :
	InvalidinputException(int lineNo, string func, string msg) : MyException(lineNo, func, msg) {}
};

int main() {
	int x, y;
	try {
		cout << "나눗셈을 합니다. 두 개의 양의 정수를 입력하세요 : ";
		cin >> x >> y;
		if (x < 0 || y < 0)
			throw InvalidinputException(32, "main()", "음수 입력 예외 발생");
		if (y == 0)
			throw DivideByZeroException(34, "main()", "0으로 나누는 예외 발생");
		cout << (double)x / (double)y;
	}
	catch (DivideByZeroException& e){
		e.print();
	}
	catch (InvalidinputException& e) {
		e.print();
	}
}
*/

/*
// generic progarmming
template <typename T>
T get_max(T x, T y) {
	if (x > y)
		return x;
	else
		return y;
}

int main() {
	cout << get_max(1, 3) << endl;
	cout << get_max(1.2, 3.9) << endl;
	return 0;
}
*/

/*
// 함수 템플릿과 함수 오버로딩
template <typename T>
void swap_values(T& x, T& y) {
	T temp;
	temp = x;
	x = y;
	y = temp;
}

void swap_values(char* s1, char* s2) {	// 함수가 추가된다면 오버로딩해서 작성할 것!
	int len;
	len = (strlen(s1) >= strlen(s2)) ? strlen(s1) : strlen(s2);
	char* tmp = new char[len + 1];

	strcpy(tmp, s1);
	strcpy(s1, s2);
	strcpy(s2, tmp);
	delete[] tmp;
}

int main() {
	int x = 100, y = 200;
	swap_values(x, y);
	cout << x << " " << y << endl;

	char s1[100] = "This is a first string.";
	char s2[100] = "This is a second string.";
	swap_values(s1, s2);
	cout << s1 << " " << s2 << endl;
	return 0;
}
*/

/*
// 두개의 타입 매개 변수를 갖는 함수 템플릿
template <typename T>
void copy_array(T a[], T b[], int n) {
	for (int i = 0; i < n; ++i)
		a[i] = b[i];
}
T get_first(T[] a) {	// Error
	return a[0];
}
*/

/*
// 클래스 템플릿 예제
template <typename T>
class Box {
	T data;
public :
	Box() {}
	void set(T value) {
		data = value;
	}
	T get() {
		return data;
	}
};

int main() {
	Box<int>box;	// 따로 타입을 작성해주어야 한다!
	box.set(100);
	cout << box.get() << endl;

	Box<double>box1;
	box1.set(3.141592);
	cout << box1.get() << endl;

	return 0;
}
*/

/*
// 두개 이상의 매개변수를 가지는 경우
template <typename T1, typename T2>
class Box2 {
	T1 first_data;
	T2 second_data;
public :
	Box2() {}
	T1 get_first();
	T2 get_second();
	void set_first(T1 value) {
		first_data = value;
	}
	void set_second(T2 value) {
		second_data = value;
	}
};

template<typename T1, typename T2>	//template를 그때마다 다 적어줘야하니까 인라인 함수로 구현하는 것이 편리하다!
T1 Box2<T1, T2>::get_first() {
	return first_data;
}

template<typename T1, typename T2>
T2 Box2<T1, T2>::get_second() {
	return second_data;
}

int main() {
	Box2<int, double>b;	// 클래스는 정의해주고 사용하자!
	b.set_first(10);
	b.set_second(3.14);
	cout << b.get_first() <<" " << b.get_second() << endl;
	return 0;
}
*/

/*
// generic myswap() function ex)
class Circle {
	int radius;
public :
	Circle(int radius = 1) {
		this->radius = radius;
	}
	int getRadius() {
		return radius;
	}
};

template <class T>
void myswap(T& a, T& b) {
	T tmp;
	tmp = a;
	a = b;
	b = tmp;
}

int main() {
	int a = 4, b = 5;
	myswap(a, b);
	cout << a << " " << b << endl;
	
	double c = 0.3, d = 12.5;
	myswap(c, d);
	cout << c << " " << d << endl;

	Circle donut(5), pizza(20);
	myswap(donut, pizza);
	cout << donut.getRadius() << ", " << pizza.getRadius() << endl;

	return 0;
}
*/

/*
// 배열의 합을 구하여 리턴하는 제네릭 add() 함수 만들기 연습
template <class T>	// class와 변수 모두 받기 위해 class라고 작성
T add(T data[], int n) {
	T sum = 0;
	for (int i = 0; i < n; i++)
		sum += data[i];
	return sum;
}

int main() {
	int x[] = { 1, 2, 3, 4, 5 };
	double d[] = { 1.2, 2.3, 3.4, 4.5, 5.6, 6.7 };

	cout << "sum of x[] = " << add(x, 5) << endl;
	cout << "sum of d[] = " << add(d, 6) << endl;
}
*/

/*
// 배열을 복사하는 제네릭 함수 mcopy() 함수 만들기 연습
template <class T1, class T2>
void mcopy(T1 src[], T2 dest[], int n) {		// T1에서 T2로 넘겨준다
	for (int i = 0; i < n; i++)
		dest[i] = (T2)src[i];		// 넘겨주는 쪽으로 캐스팅되어야 한다
}

int main() {
	int x[] = { 1, 2, 3, 4, 5 };
	double d[5];
	char c[5] = { 'H', 'e', 'l', 'l', 'o' }, e[5];
	mcopy(x, d, 5);
	mcopy(c, e, 5);

	for (int i = 0; i < 5; i++)
		cout << d[i] << " ";
	cout << endl;
	for (int i = 0; i < 5; i++)
		cout << e[i] << " ";
	cout << endl;
}
*/

/*
// 템플릿 함수보다 중복 함수가 우선임
template <class T>
void print(T array[], int n) {
	for (int i = 0; i < n; i++)
		cout << array[i] << '\t';
	cout << endl;
}

void print(char array[], int n) {	// 중복 함수가 우선으로 호출됨
	for (int i = 0; i < n; i++)
		cout << (int)array[i] << '\t';
	cout << endl;
}

int main() {
	int x[] = { 1, 2, 3, 4, 5 };
	double d[5] = { 1.1, 2.2, 3.3, 4.4, 5.5 };
	print(x, 5);
	print(d, 5);

	char c[5] = { 1, 2, 3, 4, 5 };
	print(c, 5);
}
*/

/*
// 제네릭 클래스 선언
template <class T>
class MyStack {
	int tos;
	T data[100];
public :
	MyStack();
	void push(T element);
	T pop();
};

template <class T>
MyStack<T>::MyStack() {
	tos = -1;
}

// 제네릭 클래스 구현
template <class T>
void MyStack<T>::push(T element) {
	if (tos == 99) {
		cout << "stack full";
		return;
	}
	tos++;
	data[tos] = element;
}
template <class T> T MyStack<T>::pop() {
	T retData;
	if (tos == -1) {
		cout << "stack empty";
		return 0;
	}
	retData = data[tos--];
	return retData;
}

// 클래스 구체화 및 객체 활용
int main() {
	MyStack<int> iStack;
	iStack.push(3);
	cout << iStack.pop() << endl;

	MyStack<double> dStack;
	dStack.push(3.5);
	cout << dStack.pop() << endl;

	MyStack<char>* p = new MyStack<char>();
	p->push('a');
	cout << p->pop() << endl;
	delete p;
}
*/

/*
// 예외 처리 실습 1
int main() {
	int a, b;
	cin >> a >> b;
	try {
		if (b < 0) throw "음수 불가";
		if (b == 0) throw b;
		cout << a / b << endl;
	} catch (int e) {
		cout << e << "로 나눌 수 없습니다." << endl;
	} catch (const char* s) {
		cout << s << endl;
	}
	cout << "end~~~" << endl;	// 항상 수행되는 문장!
}
*/

/*
// 예외 처리 실습 2
template <class T>
class Mystack {
	T data[5];
	int top;
public :
	Mystack() :top{ -1 } {}
	void push(T n)throw(char*) {
		if (top == 4) throw "stack is full";
		top++;
		data[top] = n;
	}
	int pop()throw(char*) {
		if (top == -1)throw "stack is empty";
		T t = data[top--];
		return t;
	}
};

int main() {
	Mystack<int> st;
	try {
		for (int i = 1; i <= 5; i++) {
			st.push(i);
		}
		
		cout << st.pop() << endl;
		cout << st.pop() << endl;
		cout << st.pop() << endl;
	}
	catch (const char *s) {
		cout << s << endl;
	}
}
*/

// 12강 파일입출력 ----------------------------------------------------------------------------------------------------------------------------

/*
// 파일 쓰기 예제
int main() {
	ofstream os{"numbers.txt"};
	if (!os) {
		cerr << "파일 오픈에 실패했습니다." << endl;
		exit(1);
	}
	for (int i = 0; i < 100; i++)
		os << i << " ";
	return 0;
}
*/

/*
// 파일 읽기 예제
int main() {
	ifstream is{ "numbers.txt" };
	if (!is) {
		cerr << "파일 오픈에 실패했습니다." << endl;
		exit(1);
	}
	int number;
	while (is) {
		is >> number;
		cout << number << " ";
	}
	cout << endl;
	return 0;
}
*/

/*
// 파일 읽고 쓰기 예제 1
int main() {
	ofstream os("sample.txt", ios::app);
	if (!os) {
		cerr << "파일 오픈에 실패했습니다." << endl;
		exit(1);
	}
	os << "추가되는 줄 #1" << endl;
	os << "추가되는 줄 #2" << endl;

	return 0;
}
*/

/*
// 단순 온도데이터 처리
int main() {
	ifstream is{ "temp.txt" };
	if (!is) {
		cerr << "파일 오픈에 실패했습니다." << endl;
		exit(1);
	}
	int hour;
	double temperature;

	while (is >> hour >> temperature) {
		cout << hour << "시 : 온도 " << temperature << endl;
	}
	return 0;
}
*/

/*
// 벡터에 저장한 후 온도 데이터 처리
class TempData {
public : 
	int hour;
	double temperature;
};

int main() {
	ifstream is{ "temp.txt" };
	if (!is) {
		cerr << "파일 오픈에 실패했습니다." << endl;
		exit(1);
	}
	vector<TempData> temps;
	int hour;
	double temperature;
	while (is >> hour >> temperature) {
		temps.push_back(TempData{ hour, temperature });
	}
	for (TempData t : temps) {
		cout << t.hour << "시 : 온도 " << t.temperature << endl;
	}

	return 0;
}
*/

/*
// get()을 이용한 텍스트 파일 읽기
int main() {
	const char* file = "C:\\Intel\\Logs\\IntelGFX.log";

	ifstream fin(file);
	if (!fin) {
		cerr << file << "열기 오류" << endl;
		return 0;
	}
	int count = 0;
	int c;
	while ((c = fin.get()) != EOF) {
		cout << (char)c;
		count++;
	}
	cout << "읽은 바이트 수는 " << count << endl;
	fin.close();
}
*/
